{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["App","container","camera","scene","renderer","phone","degX","degY","camZ","windowHalfX","window","innerWidth","windowHalfY","innerHeight","canvas","useRef","vec","Vector3","onWindowResize","aspect","updateProjectionMatrix","setSize","onDocumentMouseMove","event","clientX","Math","PI","clientY","onDocumentMouseWheel","deltaY","animate","requestAnimationFrame","position","z","rotation","set","render","useEffect","current","THREE","ambientLight","add","pointLight","onProgress","xhr","lengthComputable","percentComplete","loaded","total","console","log","round","onError","e","MTLLoader","load","materials","preload","OBJLoader","setMaterials","object","bboxCenter","setFromObject","getCenter","negate","clone","traverse","obj","Mesh","geometry","translate","x","y","lookAt","setPixelRatio","devicePixelRatio","appendChild","domElement","document","addEventListener","init","className","ref","Boolean","location","hostname","match","ReactDOM","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"iQAqLeA,MA9Kf,WACE,IAAIC,EAEAC,EACFC,EACAC,EAWEC,EANAC,EAAO,EACPC,EAAO,EACPC,EAAO,GACPC,EAAcC,OAAOC,WAAa,EAClCC,EAAcF,OAAOG,YAAc,EACjCC,EAASC,iBAAuB,MAEhCC,EAAM,IAAIC,IAwGhB,SAASC,IACPT,EAAcC,OAAOC,WAAa,EAClCC,EAAcF,OAAOG,YAAc,EAEnCX,EAAOiB,OAAST,OAAOC,WAAaD,OAAOG,YAC3CX,EAAOkB,yBAEPhB,EAASiB,QAAQX,OAAOC,WAAYD,OAAOG,aAG7C,SAASS,EAAoBC,GAC3BhB,GAAQgB,EAAMC,QAAUf,GAAeA,EAAcgB,KAAKC,GAC1DpB,GAAQiB,EAAMI,QAAUf,GAAeA,EAAca,KAAKC,GAG5D,SAASE,EAAqBL,GAI1Bf,EAFEe,EAAMM,OAAS,GACjBrB,GAFU,KAGI,EAAI,EAAIA,GAEtBA,GALU,KAMI,GAAM,GAAMA,EAc9B,SAASsB,IACPC,sBAAsBD,GATtB5B,EAAO8B,SAASC,EAAIzB,EAEhBH,GACFA,EAAM6B,SAASC,IAAI7B,EAAMC,EAAM,GAEjCH,EAASgC,OAAOjC,EAAOD,GAazB,OALAmC,qBAAU,YAhJV,WACEpC,EAAYa,EAAOwB,SAEnBpC,EAAS,IAAIqC,IACX,GACA7B,OAAOC,WAAaD,OAAOG,YAC3B,IACA,MAEKmB,SAASG,IAAI,EAAG,EAAG3B,GAI1BL,EAAQ,IAAIoC,IAEZ,IAAIC,EAAe,IAAID,IAAmB,SAAU,GACpDpC,EAAMsC,IAAID,GAEV,IAAIE,EAAa,IAAIH,IAAiB,SAAU,IAChDrC,EAAOuC,IAAIC,GACXvC,EAAMsC,IAAIvC,GAIV,IAAIyC,EAAa,SAASC,GAKxB,GAAIA,EAAIC,iBAAkB,CACxB,IAAIC,EAAmBF,EAAIG,OAASH,EAAII,MAAS,IACjDC,QAAQC,IAAIzB,KAAK0B,MAAML,GAAmB,kBAI1CM,EAAU,SAASC,GACrBJ,QAAQC,IAAIG,KASd,IAAIC,KAEDC,KAEC,sBACA,SAASC,GACPA,EAAUC,WAEV,IAAIC,KAAYC,aAAaH,GAAWD,KAEtC,sBACA,SAASK,GACPvD,EAAQuD,EAER,IACIC,GADgB,IAAItB,KAAauB,cAAczD,GAEhD0D,UAAU/C,GACVgD,SACAC,QAEH5D,EAAM6D,UAAS,SAAAC,GACTA,aAAeC,KACjBD,EAAIE,SAASC,UACXT,EAAWU,EACXV,EAAWW,EACXX,EAAW5B,MAOjB/B,EAAOuE,OAAOtE,EAAM6B,UAGpB7B,EAAMsC,IAAIpC,KAEZsC,EACAS,OAORhD,EAAW,IAAImC,KACNmC,cAAchE,OAAOiE,kBAC9BvE,EAASiB,QAAQX,OAAOC,WAAYD,OAAOG,aAC3CZ,EAAU2E,YAAYxE,EAASyE,YAE/BC,SAASC,iBAAiB,YAAazD,GAAqB,GAC5DwD,SAASC,iBAAiB,QAASnD,GAAsB,GAIzDlB,OAAOqE,iBAAiB,SAAU7D,GAAgB,GA6ClD8D,GACAlD,MACC,IAGD,yBAAKmD,UAAU,OACb,yBAAKA,UAAU,SAASC,IAAKpE,MCpKfqE,QACW,cAA7BzE,OAAO0E,SAASC,UAEe,UAA7B3E,OAAO0E,SAASC,UAEhB3E,OAAO0E,SAASC,SAASC,MACvB,2DCZNC,IAASnD,OAAO,kBAAC,EAAD,MAAS0C,SAASU,eAAe,SDqI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL/C,QAAQ+C,MAAMA,EAAMC,c","file":"static/js/main.f756b007.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport * as THREE from \"three\";\nimport { MTLLoader } from \"three/examples/jsm/loaders/MTLLoader\";\nimport { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\";\nimport { Vector3, Mesh } from \"three\";\n\nfunction App() {\n  let container;\n\n  let camera: THREE.PerspectiveCamera,\n    scene: THREE.Scene,\n    renderer: THREE.WebGLRenderer;\n\n  let mouseX = 0,\n    mouseY = 0;\n\n  let degX = 0;\n  let degY = 0;\n  let camZ = 0.2;\n  let windowHalfX = window.innerWidth / 2;\n  let windowHalfY = window.innerHeight / 2;\n  const canvas = useRef<HTMLDivElement>(null);\n  let phone: THREE.Group;\n  const vec = new Vector3();\n  function init() {\n    container = canvas.current!;\n\n    camera = new THREE.PerspectiveCamera(\n      75,\n      window.innerWidth / window.innerHeight,\n      0.01,\n      1000\n    );\n    camera.position.set(0, 0, camZ);\n\n    // scene\n\n    scene = new THREE.Scene();\n\n    var ambientLight = new THREE.AmbientLight(0xffffff, 1);\n    scene.add(ambientLight);\n\n    var pointLight = new THREE.PointLight(0xffffff, 0.1);\n    camera.add(pointLight);\n    scene.add(camera);\n\n    // model\n\n    var onProgress = function(xhr: {\n      lengthComputable: any;\n      loaded: number;\n      total: number;\n    }) {\n      if (xhr.lengthComputable) {\n        var percentComplete = (xhr.loaded / xhr.total) * 100;\n        console.log(Math.round(percentComplete) + \"% downloaded\");\n      }\n    };\n\n    var onError = function(e: any) {\n      console.log(e);\n    };\n\n    // var manager = new THREE.LoadingManager();\n    // manager.addHandler(/\\.dds$/i, new DDSLoader());\n\n    // comment in the following line and import TGALoader if your asset uses TGA textures\n    // manager.addHandler( /\\.tga$/i, new TGALoader() );\n\n    new MTLLoader()\n      // .setPath('assets/')\n      .load(\n        // \"./assets/male02_dds.mtl\",\n        \"./assets/phone.mtl\",\n        function(materials) {\n          materials.preload();\n\n          new OBJLoader().setMaterials(materials).load(\n            // \"./assets/male02.obj\",\n            \"./assets/phone.obj\",\n            function(object) {\n              phone = object;\n\n              const boundingBox = new THREE.Box3().setFromObject(phone);\n              var bboxCenter = boundingBox\n                .getCenter(vec)\n                .negate()\n                .clone();\n\n              phone.traverse(obj => {\n                if (obj instanceof Mesh) {\n                  obj.geometry.translate(\n                    bboxCenter.x,\n                    bboxCenter.y,\n                    bboxCenter.z\n                  );\n                }\n              });\n              //           pivot = new THREE.Group();\n              // scene.add( pivot );\n              // pivot.add( phone );\n              camera.lookAt(scene.position);\n\n              // phone.tran\n              scene.add(phone);\n            },\n            onProgress,\n            onError\n          );\n        }\n      );\n\n    //\n\n    renderer = new THREE.WebGLRenderer();\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    container.appendChild(renderer.domElement);\n\n    document.addEventListener(\"mousemove\", onDocumentMouseMove, false);\n    document.addEventListener(\"wheel\", onDocumentMouseWheel, false);\n\n    //\n\n    window.addEventListener(\"resize\", onWindowResize, false);\n  }\n\n  function onWindowResize() {\n    windowHalfX = window.innerWidth / 2;\n    windowHalfY = window.innerHeight / 2;\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  function onDocumentMouseMove(event: { clientX: number; clientY: number }) {\n    degY = (event.clientX - windowHalfX) / windowHalfX * Math.PI;\n    degX = (event.clientY - windowHalfY) / windowHalfY * Math.PI;\n  }\n\n  function onDocumentMouseWheel(event: WheelEvent) {\n    var scale = 0.02\n    if (event.deltaY > 0) {\n      camZ += scale\n      camZ = camZ > 1 ? 1 : camZ\n    } else {\n      camZ -= scale\n      camZ = camZ < 0.1 ? 0.1 : camZ\n    }\n  }\n\n  function render() {\n    // camera.position.x += (mouseX - camera.position.x) * 0.05;\n    camera.position.z = camZ\n\n    if (phone) {\n      phone.rotation.set(degX, degY, 0)\n    }\n    renderer.render(scene, camera);\n  }\n\n  function animate() {\n    requestAnimationFrame(animate);\n    render();\n  }\n\n  useEffect(() => {\n    init();\n    animate();\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <div className=\"canvas\" ref={canvas}></div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}